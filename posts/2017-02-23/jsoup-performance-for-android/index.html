<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-39627402-1', {
              page_path: window.location.pathname,
            });
          </script><title>Android app 中 jsoup 性能原因的分析</title><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"/><link rel="canonical" href="https://jokester.github.io/posts/2017-02-23/jsoup-performance-for-android/"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/4aea23cc4ba74f25.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4aea23cc4ba74f25.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3278669249d12298.js" defer=""></script><script src="/_next/static/chunks/framework-e6d86b677864e3f5.js" defer=""></script><script src="/_next/static/chunks/main-bd374c4482f3a8c9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f13ade3d405e605a.js" defer=""></script><script src="/_next/static/chunks/782-c0d129453d73cf2f.js" defer=""></script><script src="/_next/static/chunks/503-60468e2aaeee9d33.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-0a158f9191a6a0a4.js" defer=""></script><script src="/_next/static/79WDPIk9zHGAsq-WoX9nZ/_buildManifest.js" defer=""></script><script src="/_next/static/79WDPIk9zHGAsq-WoX9nZ/_ssgManifest.js" defer=""></script></head><body class="overflow-y-scroll"><div id="__next"><div class="bg-black text-yellow-100"><div class="min-h-screen container mx-auto"><div class="px-4 py-1 flex items-center bg-gray-900 space-x-4 text-sm"><a class="sm:hidden text-lg" href="/">挖坑自動機</a><a class="hidden sm:inline-block text-lg" href="/">挖坑自動機 / Digging automaton</a><span>|</span><a class="text-yellow-200" href="/posts/">/posts</a><a class="" href="/works/">/works</a><a class="" href="/about/">/about</a></div><div class="px-4 pt-6"><div class="markdown"><h1></h1><hr/><div class="markdown"><p>最近在 android app 中用 <a href="https://jsoup.org/">jsoup</a> 从远程 html 中抽取数据, 觉得功能甚好, 只是有点慢. 翻了源码 &amp; 做了简单测试后觉得下面这几点可以改造一下:</p>
<ol>
<li>jsoup 的用法是先 <code>parse()</code> 创建一个完整的 <code>Document</code> 对象, 然后才能 <code>select()</code> 在里面找需要的 <code>Element</code>. 其实在抽取数据时可能只需要一个或几个 <code>Element</code>.</li>
<li><code>Element.select()</code> 好像一定会遍历整个 DOM 树, 我没有见到剪枝操作.</li>
<li>即使传入 <code>InputStream</code>, jsoup 也会先全部读入才开始 parse</li>
</ol>
<p>我想要的用法 (app 里是和 RxJava 一起用):</p>
<ol>
<li>用类似 SAX 的 API 一遍完成, 只为匹配到的部分 DOM (用 css selector 指定) 创建<code>Element</code>.
不过没有 DOM 难以实现所有的 css selector 语义, 所以我打算只支持适合 SAX 且简单的 selector. 完整的 selector 功能在创建好 <code>Element</code>后用已有的 <code>.select()</code> 做就可以了)</li>
<li>边解析边返回匹配到的<code>Element</code>, 尽早把第一批结果传给 UI.</li>
<li>边读 HTTP response 边解析</li>
</ol>
<hr/>
<p>2017-03-24 更新:</p>
<p>这个月尝试了一下, 发现完全 SAX 的做法性能上是满足需要的, 但和现实中的 HTML 的兼容性颇差.</p>
<p>现实中的 HTML 往往不规整, 最大的问题可能是 tag 不配对. 为了从不规整的 HTML 得到一个能用的 DOM 树, w3c 有一个十分复杂的标准算法: <a href="https://www.w3.org/TR/html51/syntax.html#parsing-html-documents">8.2 Parsing HTML documents</a>.</p>
<p>这个算法的很多地方实质上需要一个类似 DOM 树的东西. 即使能把这个算法改造成兼容 SAX 式 API, 维护 DOM 树的时间开销可能也不会有明显减少, 最多是可以边 parse 边丢弃, 不需要整个 DOM 树同时在内存.</p>
<p>而在我的需求中, (首个匹配的 DOM 元素前的) 延迟才是最重要的因素. 所以我打算换一个方向: 给 jsoup 已有的 DOM parser 加上能发射刚匹配到的 DOM 元素的 API.</p></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2017/2017-02-23-jsoup-performance-for-android.md","slug":["2017-02-23","jsoup-performance-for-android"],"frontMatter":{"title":"Android app 中 jsoup 性能原因的分析","publishAt":"2017-02-23"}},"mdContent":"\n最近在 android app 中用 [jsoup](https://jsoup.org/) 从远程 html 中抽取数据, 觉得功能甚好, 只是有点慢. 翻了源码 \u0026 做了简单测试后觉得下面这几点可以改造一下:\n\n1. jsoup 的用法是先 `parse()` 创建一个完整的 `Document` 对象, 然后才能 `select()` 在里面找需要的 `Element`. 其实在抽取数据时可能只需要一个或几个 `Element`.\n2. `Element.select()` 好像一定会遍历整个 DOM 树, 我没有见到剪枝操作.\n3. 即使传入 `InputStream`, jsoup 也会先全部读入才开始 parse\n\n我想要的用法 (app 里是和 RxJava 一起用):\n\n1. 用类似 SAX 的 API 一遍完成, 只为匹配到的部分 DOM (用 css selector 指定) 创建`Element`.\n   不过没有 DOM 难以实现所有的 css selector 语义, 所以我打算只支持适合 SAX 且简单的 selector. 完整的 selector 功能在创建好 `Element`后用已有的 `.select()` 做就可以了)\n2. 边解析边返回匹配到的`Element`, 尽早把第一批结果传给 UI.\n3. 边读 HTTP response 边解析\n\n---\n\n2017-03-24 更新:\n\n这个月尝试了一下, 发现完全 SAX 的做法性能上是满足需要的, 但和现实中的 HTML 的兼容性颇差.\n\n现实中的 HTML 往往不规整, 最大的问题可能是 tag 不配对. 为了从不规整的 HTML 得到一个能用的 DOM 树, w3c 有一个十分复杂的标准算法: [8.2 Parsing HTML documents](https://www.w3.org/TR/html51/syntax.html#parsing-html-documents).\n\n这个算法的很多地方实质上需要一个类似 DOM 树的东西. 即使能把这个算法改造成兼容 SAX 式 API, 维护 DOM 树的时间开销可能也不会有明显减少, 最多是可以边 parse 边丢弃, 不需要整个 DOM 树同时在内存.\n\n而在我的需求中, (首个匹配的 DOM 元素前的) 延迟才是最重要的因素. 所以我打算换一个方向: 给 jsoup 已有的 DOM parser 加上能发射刚匹配到的 DOM 元素的 API.\n"},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2017-02-23","jsoup-performance-for-android"]},"buildId":"79WDPIk9zHGAsq-WoX9nZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>