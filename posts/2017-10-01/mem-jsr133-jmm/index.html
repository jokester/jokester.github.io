<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-39627402-1', {
              page_path: window.location.pathname,
            });
          </script><title>TIR: java memory model (JSR133)</title><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"/><link rel="canonical" href="https://jokester.github.io/posts/2017-10-01/mem-jsr133-jmm/"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e274a56a8c713e11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e274a56a8c713e11.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/main-bddf79548cc71113.js" defer=""></script><script src="/_next/static/chunks/pages/_app-56cab3f2bceb342c.js" defer=""></script><script src="/_next/static/chunks/782-8f2f749453de2711.js" defer=""></script><script src="/_next/static/chunks/934-d1bdf20b623d8896.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-edb93a31bb50f164.js" defer=""></script><script src="/_next/static/zVsB8sXV5JsNZvd80Veku/_buildManifest.js" defer=""></script><script src="/_next/static/zVsB8sXV5JsNZvd80Veku/_ssgManifest.js" defer=""></script><script src="/_next/static/zVsB8sXV5JsNZvd80Veku/_middlewareManifest.js" defer=""></script></head><body class="overflow-y-scroll"><div id="__next"><div class="bg-black text-yellow-100"><div class="min-h-screen container mx-auto"><div class="px-4 py-1 flex items-center bg-gray-900 space-x-4 text-sm"><a class="sm:hidden text-lg" href="/">挖坑自動機</a><a class="hidden sm:inline-block text-lg" href="/">挖坑自動機 / Digging automaton</a><span>|</span><a class="text-yellow-200" href="/posts/">/posts</a><a class="" href="/works/">/works</a><a class="" href="/about/">/about</a></div><div class="px-4 pt-6"><div class="markdown"><h1></h1><hr/><div class="markdown"><p>Java Language Spec</p>
<h2>Chapter 17: Threads and Locks</h2>
<h3>Preface</h3>
<ul>
<li>memory model defines behaviors that are allowed<!-- -->
<ul>
<li>JVMs are free to optimize (as long as they only generates allowed behavior)</li>
</ul>
</li>
</ul>
<h3>17.1 Synchronization</h3>
<ul>
<li>
<p>&#x27;most basic&#x27; synchronization mechism</p>
</li>
<li>
<p>implemented with <code>monitor</code></p>
</li>
<li>
<p>monitor:</p>
<ul>
<li>exists in each Java object</li>
<li>reentrant</li>
<li>only belongs to 1 thread at any time</li>
</ul>
</li>
<li>
<p><code>synchronized</code></p>
<ul>
<li>try to lock on the monitor before run</li>
<li>automatically unlocks when (return OR throw)</li>
<li>no non-blocking try or timeout</li>
</ul>
</li>
<li>
<p>JVM is NOT obliged to detect OR prevent deadlock</p>
</li>
</ul>
<h3>17.2 Wait Sets and Notification</h3>
<ul>
<li>Wait Set: a set of threads that are waiting &quot;on&quot; the monitor of one object</li>
<li>only affacted by <code>Object.wait()</code> / <code>Object#notify</code> / <code>Object#notifyAll</code></li>
</ul>
<h4>17.2.1 <code>Object#wait</code></h4>
<p>if</p>
<ul>
<li>caller thread (currentThread) MUST have locked the monitor</li>
<li>currentThread MUST NOT be interrupted</li>
</ul>
<p>then</p>
<ul>
<li>unlock the monitor</li>
<li>add currentThread to wait set</li>
<li>block currentThread until it gets removed from wait set<!-- -->
<ul>
<li>removal may happen if:<!-- -->
<ul>
<li>currentThread gets interrupted</li>
<li><code>notify()</code> called</li>
<li><code>notifyAll()</code> called</li>
<li>timed wait &amp;&amp; timeout</li>
</ul>
</li>
</ul>
</li>
<li>lock the monitor again</li>
<li>(if block ended due to interruption) `wait() throws InterruptedException</li>
</ul>
<h4>17.2.2 <code>Object#notify()</code> / <code>Object#notifyAll()</code></h4>
<ul>
<li>currentThread must have locked the monitor</li>
<li>remove 1 or all threads from wait set<!-- -->
<ul>
<li>in case of notifyAll, <em>ONLY 1</em> thread would be able to lock again</li>
</ul>
</li>
<li>NOTE: this DOES NOT unlock the monitor (so NO thread removed from Wait Set can succeed until currentThread unlocks)</li>
</ul>
<h4>17.2.3 Interruptions</h4>
<h4>17.2.4 Interactions of waits / notifation / interruption</h4>
<h3>17.3 Sleep and Yield</h3>
<p><code>Thread.sleep()</code> / <code>Thread.yield()</code></p>
<ul>
<li>sleep DOES NOT lose ownership of monitors</li>
<li>NEITHER Thread.sleep NOR have synchronization semantics</li>
</ul>
<h3>17.4 Memory Model</h3>
<p>&quot;possible behaviors of a program&quot;</p>
<ul>
<li>
<p>whether an execution trace (instructions?) is a legal execution of the program (code?)</p>
</li>
<li>
<p>&quot;legal&quot; := each <em>read</em> MUST observe some <em>write</em> that is valid according to certain rules</p>
</li>
<li>
<p>intra-thread semantics</p>
<ul>
<li>semantics for single-threaded programs</li>
</ul>
</li>
</ul>
<h4>17.4.1 Shared Variables</h4>
<ul>
<li>&quot;shared variable&quot;: instance fields / static fields / array elements<!-- -->
<ul>
<li>in contrast to single-threaded : local variables / method params / execution handler params</li>
</ul>
</li>
<li>&quot;conflicting&quot;: two accesses to the same variable if at least 1 of them is write</li>
</ul>
<h4>17.4.2 Actions</h4>
<p><strong>inter-thread action</strong> or simply &quot;action&quot;: an action that can be detected or directly-influenced by another thread</p>
<p>intra-thread actions do not concern us: all threads need to obey intra-thread semantics</p>
<p>possible (inter-thread) actions:</p>
<ul>
<li>non-volatile read</li>
<li>non-volatile write</li>
<li><strong>synchronized actions</strong>
<ul>
<li>volatile read</li>
<li>volatile write</li>
<li>lock of monitor</li>
<li>unlock of monitor</li>
<li>first and last action of a thread</li>
<li>actions that start a thread, or detect termination of a thread</li>
</ul>
</li>
<li>&quot;external&quot; action<!-- -->
<ul>
<li>an action that may be observable outside of an execution (<code>side effect</code> ?), and have a result based on an environment external to the execution (<code>RealWorld</code> ?)</li>
</ul>
</li>
<li>thread divergence action, or &quot;dead loop&quot;</li>
</ul>
<h4>17.4.3 Programs and Program Order</h4>
<p>(<em>program order</em> of thread <em>t</em>): a total order that obeys intra-thread semantics of <em>t</em></p>
<p>a set of actions is <em>sequentially consistent</em> if</p>
<ul>
<li>the actions occur in a total order <em>&quot;execution order</em> that is consistent with program order</li>
<li>AND each read r of variable v sees (last write to v in execution order)</li>
</ul>
<p>&quot;sequential consistency&quot; as a language model prohibits many compiler optimizations</p>
<h4>17.4.4 Synchronization order</h4>
<p>a synchronization order is a total order over all the <em>synchronization actions</em> of an execution.</p>
<p>For each thread t, the <strong>synchronization order</strong> of synchronization actions in t is consistent with the <strong>program order</strong> of t.</p>
<p>Synchronization actions induce <strong>synchronized-with</strong> relation relation of actions:</p>
<ul>
<li>unlock <em>synchronized-with</em> all subsequent lock</li>
<li>a volatile write <em>synchronized-with</em> all subsequent volatile read</li>
<li>starting a thread <em>synchronized-with</em> first action in that thread</li>
<li>final action of a thread T <em>synchronized-with</em> actions of thread T2, if T2 dectes T has terminatedd</li>
<li>interruption of thread blah blah</li>
<li>write of default value <em>synchronized-with</em> first action in every thread<!-- -->
<ul>
<li>&quot;conceptually every object is created at start of program&quot;</li>
</ul>
</li>
</ul>
<h4>17.4.5 Happens-before order</h4>
<p>2 actions can be ordered by a <strong>happens-before</strong> relationship</p>
<p>If x happens before y, then: x is visible to y AND is ordered before y</p>
<p>x happens before y if:</p>
<ul>
<li>x and y are actions of the same thread, and x comes before y in program order</li>
<li>OR: x is (end of constructor) and y is (start of finalizer)</li>
<li>OR: x synchronized-with y</li>
<li>OR: x happens-before some z, and z happens-before y (i.e. happens-before is a transitive relation)</li>
</ul>
<p>NOTE: happens-before does not require certain order in execution (implementation may reorder as long as all observations obeys <em>happens-before</em>)</p>
<p>happens-before relation defines <strong>data races</strong>: if 2 <strong>conflicting accesses</strong> are not ordered by a <strong>happens-before</strong> relationship, the program is said to contain a <strong>data race</strong>.</p>
<p>a program is <strong>correctly synchronized</strong> IFF all sequentially consistent executions are free of data races.</p>
<p>if a program is <strong>correctly synchronized</strong>, then <strong>all</strong> executions of the program will appear to be sequentially consistent</p>
<p>read r of varable v is allowed to observe a write w if</p>
<p><strong>happens-before consistency</strong>:</p></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2017/2017-10-01-mem-jsr133-jmm.md","slug":["2017-10-01","mem-jsr133-jmm"],"frontMatter":{"title":"TIR: java memory model (JSR133)","publishAt":"2017-10-01"}},"mdContent":"\nJava Language Spec\n\n## Chapter 17: Threads and Locks\n\n### Preface\n\n- memory model defines behaviors that are allowed\n  - JVMs are free to optimize (as long as they only generates allowed behavior)\n\n### 17.1 Synchronization\n\n- 'most basic' synchronization mechism\n- implemented with `monitor`\n- monitor:\n  - exists in each Java object\n  - reentrant\n  - only belongs to 1 thread at any time\n- `synchronized`\n\n  - try to lock on the monitor before run\n  - automatically unlocks when (return OR throw)\n  - no non-blocking try or timeout\n\n- JVM is NOT obliged to detect OR prevent deadlock\n\n### 17.2 Wait Sets and Notification\n\n- Wait Set: a set of threads that are waiting \"on\" the monitor of one object\n- only affacted by `Object.wait()` / `Object#notify` / `Object#notifyAll`\n\n#### 17.2.1 `Object#wait`\n\nif\n\n- caller thread (currentThread) MUST have locked the monitor\n- currentThread MUST NOT be interrupted\n\nthen\n\n- unlock the monitor\n- add currentThread to wait set\n- block currentThread until it gets removed from wait set\n  - removal may happen if:\n    - currentThread gets interrupted\n    - `notify()` called\n    - `notifyAll()` called\n    - timed wait \u0026\u0026 timeout\n- lock the monitor again\n- (if block ended due to interruption) `wait() throws InterruptedException\n\n#### 17.2.2 `Object#notify()` / `Object#notifyAll()`\n\n- currentThread must have locked the monitor\n- remove 1 or all threads from wait set\n  - in case of notifyAll, _ONLY 1_ thread would be able to lock again\n- NOTE: this DOES NOT unlock the monitor (so NO thread removed from Wait Set can succeed until currentThread unlocks)\n\n#### 17.2.3 Interruptions\n\n#### 17.2.4 Interactions of waits / notifation / interruption\n\n### 17.3 Sleep and Yield\n\n`Thread.sleep()` / `Thread.yield()`\n\n- sleep DOES NOT lose ownership of monitors\n- NEITHER Thread.sleep NOR have synchronization semantics\n\n### 17.4 Memory Model\n\n\"possible behaviors of a program\"\n\n- whether an execution trace (instructions?) is a legal execution of the program (code?)\n- \"legal\" := each _read_ MUST observe some _write_ that is valid according to certain rules\n\n- intra-thread semantics\n  - semantics for single-threaded programs\n\n#### 17.4.1 Shared Variables\n\n- \"shared variable\": instance fields / static fields / array elements\n  - in contrast to single-threaded : local variables / method params / execution handler params\n- \"conflicting\": two accesses to the same variable if at least 1 of them is write\n\n#### 17.4.2 Actions\n\n**inter-thread action** or simply \"action\": an action that can be detected or directly-influenced by another thread\n\nintra-thread actions do not concern us: all threads need to obey intra-thread semantics\n\npossible (inter-thread) actions:\n\n- non-volatile read\n- non-volatile write\n- **synchronized actions**\n  - volatile read\n  - volatile write\n  - lock of monitor\n  - unlock of monitor\n  - first and last action of a thread\n  - actions that start a thread, or detect termination of a thread\n- \"external\" action\n  - an action that may be observable outside of an execution (`side effect` ?), and have a result based on an environment external to the execution (`RealWorld` ?)\n- thread divergence action, or \"dead loop\"\n\n#### 17.4.3 Programs and Program Order\n\n(_program order_ of thread _t_): a total order that obeys intra-thread semantics of _t_\n\na set of actions is _sequentially consistent_ if\n\n- the actions occur in a total order _\"execution order_ that is consistent with program order\n- AND each read r of variable v sees (last write to v in execution order)\n\n\"sequential consistency\" as a language model prohibits many compiler optimizations\n\n#### 17.4.4 Synchronization order\n\na synchronization order is a total order over all the _synchronization actions_ of an execution.\n\nFor each thread t, the **synchronization order** of synchronization actions in t is consistent with the **program order** of t.\n\nSynchronization actions induce **synchronized-with** relation relation of actions:\n\n- unlock _synchronized-with_ all subsequent lock\n- a volatile write _synchronized-with_ all subsequent volatile read\n- starting a thread _synchronized-with_ first action in that thread\n- final action of a thread T _synchronized-with_ actions of thread T2, if T2 dectes T has terminatedd\n- interruption of thread blah blah\n- write of default value _synchronized-with_ first action in every thread\n  - \"conceptually every object is created at start of program\"\n\n#### 17.4.5 Happens-before order\n\n2 actions can be ordered by a **happens-before** relationship\n\nIf x happens before y, then: x is visible to y AND is ordered before y\n\nx happens before y if:\n\n- x and y are actions of the same thread, and x comes before y in program order\n- OR: x is (end of constructor) and y is (start of finalizer)\n- OR: x synchronized-with y\n- OR: x happens-before some z, and z happens-before y (i.e. happens-before is a transitive relation)\n\nNOTE: happens-before does not require certain order in execution (implementation may reorder as long as all observations obeys _happens-before_)\n\nhappens-before relation defines **data races**: if 2 **conflicting accesses** are not ordered by a **happens-before** relationship, the program is said to contain a **data race**.\n\na program is **correctly synchronized** IFF all sequentially consistent executions are free of data races.\n\nif a program is **correctly synchronized**, then **all** executions of the program will appear to be sequentially consistent\n\nread r of varable v is allowed to observe a write w if\n\n**happens-before consistency**:\n"},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2017-10-01","mem-jsr133-jmm"]},"buildId":"zVsB8sXV5JsNZvd80Veku","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>