<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-39627402-1', {
              page_path: window.location.pathname,
            });
          </script><title>Note for SICP Chapter 1</title><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"/><link rel="canonical" href="https://jokester.github.io/posts/2014-05-16/sicp-chapter-1/"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/4aea23cc4ba74f25.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4aea23cc4ba74f25.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3278669249d12298.js" defer=""></script><script src="/_next/static/chunks/framework-e6d86b677864e3f5.js" defer=""></script><script src="/_next/static/chunks/main-bd374c4482f3a8c9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f13ade3d405e605a.js" defer=""></script><script src="/_next/static/chunks/782-c0d129453d73cf2f.js" defer=""></script><script src="/_next/static/chunks/503-60468e2aaeee9d33.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-0a158f9191a6a0a4.js" defer=""></script><script src="/_next/static/_QvQikHdy6XDN8mZszHK8/_buildManifest.js" defer=""></script><script src="/_next/static/_QvQikHdy6XDN8mZszHK8/_ssgManifest.js" defer=""></script></head><body class="overflow-y-scroll"><div id="__next"><div class="bg-black text-yellow-100"><div class="min-h-screen container mx-auto"><div class="px-4 py-1 flex items-center bg-gray-900 space-x-4 text-sm"><a class="sm:hidden text-lg" href="/">挖坑自動機</a><a class="hidden sm:inline-block text-lg" href="/">挖坑自動機 / Digging automaton</a><span>|</span><a class="text-yellow-200" href="/posts/">/posts</a><a class="" href="/works/">/works</a><a class="" href="/about/">/about</a></div><div class="px-4 pt-6"><div class="markdown"><h1></h1><hr/><div class="markdown"><ul>
<li>toc
{:toc}</li>
</ul>
<h4>Building Abstractions with Procedures</h4>
<h5>The Elements of Programming</h5>
<h6>Expressions</h6>
<ul>
<li>
<p>primitive expression</p>
<ul>
<li>number: <code>486</code></li>
<li>primitive operators (are also procedures): <code>&lt; = &gt; and or not</code></li>
</ul>
</li>
<li>
<p>compound expression</p>
<ul>
<li>application of some <strong>procedure</strong> to some <strong>arguments</strong>: <code>(+ 1 2)</code></li>
</ul>
</li>
</ul>
<h6>Naming and the Environment</h6>
<ul>
<li>
<p>naming: assign name to something (&quot;object&quot;)</p>
<ul>
<li>value: <code>(define foo 1)</code></li>
<li>procedure: <code>(define (bar arg1) (+ 1 2))</code></li>
</ul>
</li>
<li>
<p>environment: memory of name-object pairs</p>
<ul>
<li>a computation may involve multiple environments</li>
</ul>
</li>
</ul>
<h6>Evaluating Combinations</h6>
<ul>
<li>
<p>steps of &quot;applicative order&quot;</p>
<ul>
<li>evaluate every subexpressions</li>
<li>apply the leftmost subexpression (&quot;operator&quot;) to the values of the other subexpressions (&quot;operands&quot;)</li>
</ul>
</li>
</ul>
<h6>Compound Procedures</h6>
<ul>
<li>general form of procedure definition:</li>
</ul>
<pre><code>      (define (&lt;name&gt; &lt;formal parameters&gt;)
          &lt;body&gt;)
</code></pre>
<pre><code>The `&lt;body&gt;&#x27; part may contain multiple expressions. The value of the final expression becomes the value of the procedure application.
</code></pre>
<h6>The Substitution Model for Procedure Application</h6>
<ul>
<li>
<p>evaluate the body of procedure with the formal parameters replaced by the corresponding arguments</p>
</li>
<li>
<p>is presented to help think about the process of application, and <strong>is not</strong> how interpreter works</p>
</li>
<li>
<p>order of execution</p>
<ul>
<li>normal order: &quot;fully expand and then reduce&quot;</li>
<li>applicative order: &quot;evaluate the arguments and then apply&quot;</li>
<li>lisp uses applicative order evaluation.</li>
</ul>
</li>
</ul>
<h6>Conditional Expressions and Predicates</h6>
<ul>
<li>
<p>if</p>
<p><code>if</code> is a special form and not a procedure.
It only evalutes the predicate and <strong>one of</strong> the consequent / alternative expression.</p>
<pre><code>(if (&gt; 1 0) #t #f)
</code></pre>
</li>
<li>
<p>cond</p>
<p><code>cond</code> is a special form and not a procedure.
It only evalutes the predicates till the correct branch, and that corresponding branch.</p>
<pre><code>(cond
    ((= a 1) 1)
    ((= a 2) 3))
</code></pre>
</li>
</ul>
<h6>Example: Square Roots by Newton’s Method</h6>
<ul>
<li>
<p>code</p>
<pre><code>(define (newton-sqrt aim)
  (define (guess-till-good-enough current next-guess good-enough?)
    (if (good-enough? current)
      current
      (guess-till-good-enough (next-guess current) next-guess good-enough?)))
  (define (small-enough? delta) (&lt; delta 1e-5))
  (define (close-enough? current) (small-enough? (abs (- (* current current) aim))))
  (define (better-approximation-of-sqrt current) (/ (+ current (/ aim current)) 2)) ;; &lt;&lt; the ``Newton&#x27;&#x27; part
  (define initial-guess 1.1)
  (guess-till-good-enough initial-guess better-approximation-of-sqrt close-enough?))

(display (newton-sqrt 2.0))
; =&gt; 1.4142
</code></pre>
</li>
</ul>
<h6>Procedures as Black-Box Abstractions</h6>
<ul>
<li>
<p>The definition suppresses the details.</p>
</li>
<li>
<p>The user of a procedure does not need to know the internal.</p>
</li>
<li>
<p>Local names</p>
<ul>
<li>The formal parameters are <strong>local</strong> to the body. AKA &quot;bound variable&quot; or &quot;captured variable&quot;</li>
<li>e.g. <code>(define (square x) (* x x))</code> contains a bound variable <code>x</code> and a free variable <code>*</code>.</li>
<li>The name of formal parameters can be arbitrary.</li>
</ul>
</li>
<li>
<p>Internal definitions (refer to previous <code>newton-sqrt</code> procedure)</p>
<ul>
<li>One can localize subprocedures with nested <code>define</code>.</li>
<li>The free variable in inner procedure get its value from the bound variable of outer procedure, AKA <strong>lexical scoping</strong>.</li>
<li>Example of lexical scoping: <code>aim</code> in <code>(define (close-enough? current &lt;body&gt;)</code>.</li>
</ul>
</li>
</ul>
<h5>Procedures and the Processes They Generate</h5>
<h6>Linear Recursion and Iteration</h6>
<ul>
<li>
<p>Recursive computation of factorial</p>
<pre><code>(define (factorial n)
  (if (= n 0)
    1
    (* n (factorial (- n 1)))))
</code></pre>
</li>
<li>
<p>Iterative computation of factorial</p>
<pre><code>(define (factorial n)
  (define (factorial-iter cumulative-product current max)
    (if (&gt; max current)
      cumulative-product
      (factorial-iter (* cumulative-product current) (+ current 1) max)))
  (factorial-iter 1 1 n))
</code></pre>
</li>
<li>
<p>The preceding 2 procedures produce different <strong>shape of computation</strong>.</p>
</li>
</ul>
<h6>Tree Recursion</h6>
<ul>
<li>
<p>Example: recursive definition of <code>(fib n)</code></p>
</li>
<li>
<p>Example: counting change</p>
<pre><code>(define (change coins rest)
  (cond
    ((&lt; rest 0) 0)
    ((= rest 0) 1)
    ((= (length coins) 0) 0)
    (else (+
      (change coins (- rest (car coins)))
      (change (cdr coins) rest)))))
(display (change (list 50 25 10 5 1) 100))
; =&gt; 292
</code></pre>
</li>
</ul>
<h6>Order of Growth</h6>
<ul>
<li>refer to <strong>shape of computation</strong></li>
</ul>
<h6>Exponentiation</h6>
<ul>
<li>
<p>implement <code>(power base exp)</code> with linear recursion</p>
</li>
<li>
<p>implement <code>(power base exp)</code> with log recursion</p>
</li>
<li>
<p>exercise 1.19: implement <code>(fib n)</code> with log recursion
(let ((a 1)) (+ a 2))</p>
</li>
</ul>
<h6>Greatest Common Divisors</h6>
<ul>
<li>Euclid’s Algorithm</li>
</ul>
<h6>Example: Testing for Primality</h6>
<ul>
<li>
<p>code</p>
<pre><code>(define (prime? n)
  (define (find-first-divisor current)
    (cond
      ((= (remainder n current) 0) current)
      ((&gt; (* current current) n)   #f)
      (else (find-first-divisor (+ 1 current)))))
  (define first-divisor (find-first-divisor 2))
  (if (and first-divisor (not (= n first-divisor)))
    #f
    #t))
</code></pre>
</li>
</ul>
<h5>Formulating Abstractions with Higher-Order Procedures</h5>
<h6>Procedures as Arguments</h6>
<ul>
<li><code>map</code></li>
<li><code>sum</code>, <code>integral</code></li>
</ul>
<h6>Constructing Procedures Using Lambda</h6>
<ul>
<li>
<p>One can create (anonymous) procedures with the special form <code>lambda</code></p>
<ul>
<li>
<p>usage</p>
<pre><code>(lambda (formal-parameters) &lt;body&gt;)
</code></pre>
</li>
<li>
<p>example</p>
<pre><code>(map (lambda (x) (* x x)) &#x27;(1 2 3))
</code></pre>
</li>
</ul>
</li>
<li>
<p>One can use <code>lambda</code> to bind local variables, but the special form <code>let</code> makes it more convenient.</p>
<ul>
<li>
<p>usage</p>
<pre><code>(let ((&lt;name&gt; &lt;expression&gt;)+) &lt;body&gt;)
</code></pre>
</li>
<li>
<p>&quot;is but syntactic sugar of underlying lambda expression&quot;</p>
</li>
<li>
<p>The name-expression pairs in <code>let</code> are parallel. One expression cannot refer to another name.</p>
</li>
</ul>
</li>
</ul>
<h6>Procedures as General Methods</h6>
<ul>
<li>
<p>Example: finding zero-point with the half-interval method</p>
</li>
<li>
<p>Example: finding fixed-point</p>
</li>
</ul>
<h6>Procedures as Returned Values</h6>
<ul>
<li>rights of <strong>first-class</strong> elements<!-- -->
<ul>
<li>can be assigned a name</li>
<li>can be passed as argument</li>
<li>can be returned by procedure</li>
<li>can be included in data structures</li>
</ul>
</li>
</ul></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/series/sicp/2014-05-16-sicp-chapter-1.markdown","slug":["2014-05-16","sicp-chapter-1"],"frontMatter":{"title":"Note for SICP Chapter 1","publishAt":"2014-05-16"}},"mdContent":"\n* toc\n{:toc}\n\n#### Building Abstractions with Procedures\n\n##### The Elements of Programming\n\n###### Expressions\n\n- primitive expression\n    - number: `486`\n    - primitive operators (are also procedures): `\u003c = \u003e and or not`\n\n- compound expression\n    - application of some **procedure** to some **arguments**: `(+ 1 2)`\n\n###### Naming and the Environment\n\n- naming: assign name to something (\"object\")\n    - value: `(define foo 1)`\n    - procedure: `(define (bar arg1) (+ 1 2))`\n\n- environment: memory of name-object pairs\n    - a computation may involve multiple environments\n\n###### Evaluating Combinations\n\n- steps of \"applicative order\"\n\n    - evaluate every subexpressions\n    - apply the leftmost subexpression (\"operator\") to the values of the other subexpressions (\"operands\")\n\n###### Compound Procedures\n\n- general form of procedure definition:\n\n```\n      (define (\u003cname\u003e \u003cformal parameters\u003e)\n          \u003cbody\u003e)\n```\n\n    The `\u003cbody\u003e' part may contain multiple expressions. The value of the final expression becomes the value of the procedure application.\n\n###### The Substitution Model for Procedure Application\n\n- evaluate the body of procedure with the formal parameters replaced by the corresponding arguments\n\n- is presented to help think about the process of application, and **is not** how interpreter works\n\n- order of execution\n    - normal order: \"fully expand and then reduce\"\n    - applicative order: \"evaluate the arguments and then apply\"\n    - lisp uses applicative order evaluation.\n\n###### Conditional Expressions and Predicates\n- if\n\n    `if` is a special form and not a procedure.\n    It only evalutes the predicate and **one of** the consequent / alternative expression.\n\n      (if (\u003e 1 0) #t #f)\n\n- cond\n\n    `cond` is a special form and not a procedure.\n    It only evalutes the predicates till the correct branch, and that corresponding branch.\n\n      (cond\n          ((= a 1) 1)\n          ((= a 2) 3))\n\n###### Example: Square Roots by Newton’s Method\n\n- code\n\n      (define (newton-sqrt aim)\n        (define (guess-till-good-enough current next-guess good-enough?)\n          (if (good-enough? current)\n            current\n            (guess-till-good-enough (next-guess current) next-guess good-enough?)))\n        (define (small-enough? delta) (\u003c delta 1e-5))\n        (define (close-enough? current) (small-enough? (abs (- (* current current) aim))))\n        (define (better-approximation-of-sqrt current) (/ (+ current (/ aim current)) 2)) ;; \u003c\u003c the ``Newton'' part\n        (define initial-guess 1.1)\n        (guess-till-good-enough initial-guess better-approximation-of-sqrt close-enough?))\n\n      (display (newton-sqrt 2.0))\n      ; =\u003e 1.4142\n\n###### Procedures as Black-Box Abstractions\n\n- The definition suppresses the details.\n\n- The user of a procedure does not need to know the internal.\n\n- Local names\n    - The formal parameters are **local** to the body. AKA \"bound variable\" or \"captured variable\"\n    - e.g. `(define (square x) (* x x))` contains a bound variable `x` and a free variable `*`.\n    - The name of formal parameters can be arbitrary.\n\n- Internal definitions (refer to previous `newton-sqrt` procedure)\n    - One can localize subprocedures with nested `define`.\n    - The free variable in inner procedure get its value from the bound variable of outer procedure, AKA **lexical scoping**.\n    - Example of lexical scoping: `aim` in `(define (close-enough? current \u003cbody\u003e)`.\n\n##### Procedures and the Processes They Generate\n\n###### Linear Recursion and Iteration\n\n- Recursive computation of factorial\n\n      (define (factorial n)\n        (if (= n 0)\n          1\n          (* n (factorial (- n 1)))))\n\n- Iterative computation of factorial\n\n      (define (factorial n)\n        (define (factorial-iter cumulative-product current max)\n          (if (\u003e max current)\n            cumulative-product\n            (factorial-iter (* cumulative-product current) (+ current 1) max)))\n        (factorial-iter 1 1 n))\n\n- The preceding 2 procedures produce different **shape of computation**.\n\n###### Tree Recursion\n\n- Example: recursive definition of `(fib n)`\n\n- Example: counting change\n\n      (define (change coins rest)\n        (cond\n          ((\u003c rest 0) 0)\n          ((= rest 0) 1)\n          ((= (length coins) 0) 0)\n          (else (+\n            (change coins (- rest (car coins)))\n            (change (cdr coins) rest)))))\n      (display (change (list 50 25 10 5 1) 100))\n      ; =\u003e 292\n\n###### Order of Growth\n\n- refer to **shape of computation**\n\n###### Exponentiation\n\n- implement `(power base exp)` with linear recursion\n\n- implement `(power base exp)` with log recursion\n- exercise 1.19: implement `(fib n)` with log recursion\n        (let ((a 1)) (+ a 2))\n\n###### Greatest Common Divisors\n\n- Euclid’s Algorithm\n\n###### Example: Testing for Primality\n\n- code\n\n      (define (prime? n)\n        (define (find-first-divisor current)\n          (cond\n            ((= (remainder n current) 0) current)\n            ((\u003e (* current current) n)   #f)\n            (else (find-first-divisor (+ 1 current)))))\n        (define first-divisor (find-first-divisor 2))\n        (if (and first-divisor (not (= n first-divisor)))\n          #f\n          #t))\n\n##### Formulating Abstractions with Higher-Order Procedures\n\n###### Procedures as Arguments\n\n- `map`\n- `sum`, `integral`\n\n###### Constructing Procedures Using Lambda\n\n- One can create (anonymous) procedures with the special form `lambda`\n\n    - usage\n\n          (lambda (formal-parameters) \u003cbody\u003e)\n\n    - example\n\n          (map (lambda (x) (* x x)) '(1 2 3))\n\n- One can use `lambda` to bind local variables, but the special form `let` makes it more convenient.\n\n    - usage\n\n          (let ((\u003cname\u003e \u003cexpression\u003e)+) \u003cbody\u003e)\n\n    - \"is but syntactic sugar of underlying lambda expression\"\n\n    - The name-expression pairs in `let` are parallel. One expression cannot refer to another name.\n\n###### Procedures as General Methods\n\n- Example: finding zero-point with the half-interval method\n\n- Example: finding fixed-point\n\n###### Procedures as Returned Values\n\n- rights of **first-class** elements\n    - can be assigned a name\n    - can be passed as argument\n    - can be returned by procedure\n    - can be included in data structures\n"},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2014-05-16","sicp-chapter-1"]},"buildId":"_QvQikHdy6XDN8mZszHK8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>