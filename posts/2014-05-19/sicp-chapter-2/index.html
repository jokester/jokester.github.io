<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-39627402-1', {
              page_path: window.location.pathname,
            });
          </script><title>Note for SICP Chapter 2</title><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"/><link rel="canonical" href="https://jokester.github.io/posts/2014-05-19/sicp-chapter-2/"/><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/e274a56a8c713e11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e274a56a8c713e11.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/main-bddf79548cc71113.js" defer=""></script><script src="/_next/static/chunks/pages/_app-56cab3f2bceb342c.js" defer=""></script><script src="/_next/static/chunks/782-8f2f749453de2711.js" defer=""></script><script src="/_next/static/chunks/934-d1bdf20b623d8896.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-edb93a31bb50f164.js" defer=""></script><script src="/_next/static/zVsB8sXV5JsNZvd80Veku/_buildManifest.js" defer=""></script><script src="/_next/static/zVsB8sXV5JsNZvd80Veku/_ssgManifest.js" defer=""></script><script src="/_next/static/zVsB8sXV5JsNZvd80Veku/_middlewareManifest.js" defer=""></script></head><body class="overflow-y-scroll"><div id="__next"><div class="bg-black text-yellow-100"><div class="min-h-screen container mx-auto"><div class="px-4 py-1 flex items-center bg-gray-900 space-x-4 text-sm"><a class="sm:hidden text-lg" href="/">挖坑自動機</a><a class="hidden sm:inline-block text-lg" href="/">挖坑自動機 / Digging automaton</a><span>|</span><a class="text-yellow-200" href="/posts/">/posts</a><a class="" href="/works/">/works</a><a class="" href="/about/">/about</a></div><div class="px-4 pt-6"><div class="markdown"><h1></h1><hr/><div class="markdown"><ul>
<li>toc
{:toc}</li>
</ul>
<h4>Building Abstractions with Data</h4>
<h5>Introduction to Data Abstraction</h5>
<h6>Example: Arithmetic Operations for Rational Numbers</h6>
<ul>
<li>
<p><code>cons</code> forges a pair. <code>car</code>, <code>cdr</code> takes value out of a pair.</p>
<ul>
<li>example: <code>(car (cons a b)) ; =&gt;a</code>, <code>(cdr (cons a b)) ; =&gt;b</code>.</li>
</ul>
</li>
<li>
<p>list is but a special form of pair</p>
<ul>
<li><code>&#x27;()</code> or <code>nil</code> is a list<!-- -->
<ul>
<li><code>nil</code> is not available in MIT-scheme.</li>
</ul>
</li>
<li>The return value of <code>(cons something &lt;a-list&gt;)</code> is also a list</li>
<li><code>(list a1 a2 ... an)</code> is short for <code>(cons a1 (cons a2 ... (cons an nil) ... ))</code></li>
<li>In the other direction, a pair is an improper list</li>
</ul>
</li>
</ul>
<h6>Abstraction Barriers</h6>
<h6>What Is Meant by Data?</h6>
<ul>
<li>&quot;the ability to manipulate procedures as objects automatically provides the ability to represent compound data.&quot;</li>
</ul>
<h6>Extended Exercise: Interval Arithmetic</h6>
<h5>Hierarchical Data and the Closure Property</h5>
<h6>Representing Sequences</h6>
<ul>
<li>
<p><code>(cons something a-list)</code> yields another list.</p>
</li>
<li>
<p><code>(append list1 list2)</code> returns concatenation of list1 and list2.</p>
</li>
<li>
<p>dotted-tail notation: <code>(define (foo arg1 arg2 . rest ) &lt;body&gt;)</code></p>
<ul>
<li>arg1, arg2 capture the first 2 arguments, rest captures the rest.</li>
</ul>
</li>
</ul>
<h6>Hierarchical Structures</h6>
<ul>
<li>
<p><code>(cons (list 1 2) (list 3 4))</code> denotes a tree.</p>
</li>
<li>
<p>Exercise 2.27: a deep-reverse procedure</p>
<pre><code>(define (deep-reverse arg)
  (if (list? arg)
    (reverse (map deep-reverse a-list))
    arg))
(deep-reverse &#x27;(1 (2 3) (4 (5 6)))) ; =&gt;
</code></pre>
</li>
<li>
<p>Exercise 2.28: flattening a tree (nested list) in left-right order</p>
<pre><code>(define (fringe arg)
  (if (list? arg)
    (apply append (map fringe arg))
    (list arg)))
(display (fringe (list 1 (list 2) (list 3 4 (list 5)) 6)))
; =&gt; (1 2 3 4 5 6)
</code></pre>
</li>
<li>
<p>Exercise 2.31: a tree-map procedure</p>
<pre><code>(define (map-tree proc arg)
  (if (list? arg)
    (map (lambda (x) (map-tree proc x)) arg)
    (proc arg)))
(define (square x) (* x x))
(display
  (map-tree
    square
    &#x27;(1 2 (3 4 (5)))) )
; =&gt; (1 4 (9 16 (25)))
</code></pre>
</li>
</ul>
<h6>Sequences as Conventional Interfaces</h6>
<ul>
<li>&quot;basic&quot; operations on a bunch of things:<!-- -->
<ul>
<li>
<p>enumerate: transform something into a list</p>
</li>
<li>
<p>filter: select from a list</p>
<pre><code>(filter precidate a-list) ; =&gt;list
</code></pre>
</li>
<li>
<p>map: transform the list via a proc</p>
<pre><code>(map proc a-list) ; =&gt;list
</code></pre>
</li>
<li>
<p>accumulate: fold a list of things, a.k.a &quot;fold-right&quot;</p>
<pre><code>(define (accumulate op init a-list)
  (if (null? a-list)
    init
    (op (car a-list)
        (accumulate op init (cdr a-list)))))
;
;       op
;      /  \
;    car   op
;         /  \
;       cadr ...
;               \
;                op
;               /  \
;            last  init  ; init is to the &quot;RIGHT&quot; of l
</code></pre>
</li>
<li>
<p>Use of the preceding &quot;basic&quot; operations encourage modular design</p>
<ul>
<li>Because one have to fit to the known-to-be-common-enough interfaces</li>
</ul>
</li>
<li>
<p>filter and map can be implemented using accumulate</p>
</li>
<li>
<p>Exercise 2.33: implement <code>map</code>, <code>append</code>, <code>my-length</code> with accumulate</p>
<pre><code>(define (my-map proc sequence)
  (accumulate
    (lambda (head acc) (cons (proc head) acc))
    &#x27;()
    sequence))
(define (my-append seq1 seq2)
  (accumulate
    (lambda (head acc) (cons head acc))
    seq2
    seq1))
(define (my-length sequence)
  (accumulate
    (lambda (head acc) (+ 1 acc))
    0
    sequence))
</code></pre>
</li>
<li>
<p>Exercise 2.36: implement <code>accumulate-n</code> with <code>accumulate</code></p>
<pre><code>(define (accumulate-n op init seqs)
  (if (null? (car seqs))
        &#x27;()
        (cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
(accumulate-n
  +
  0
  &#x27;((1  2  3)
    (4  5  6)
    (7  8  9)
    (10 11 12))) ; =&gt; &#x27;(22 26 30)
</code></pre>
</li>
<li>
<p>Exercise 2.38: fold-left</p>
<pre><code>(define (my-fold-left op init sequence)
  (if (null? sequence)
    init
    (my-fold-left
      op
      (op init (car sequence))
      (cdr sequence))))
;                        op
;                       /  \
;                    ...   last
;                    /
;                  op
;                 /  \
;               op   cadr
;              /  \
; &quot;LEFT&quot;: initial  car
</code></pre>
<ul>
<li>a sufficient condition: when binary operator <code>op</code> satisfies <code>op(a,b) 三 op(b,a)</code></li>
</ul>
</li>
<li>
<p>Exercise 2.40: unique-pairs</p>
</li>
<li>
<p>Exercise 2.41: eight-queens puzzle</p>
</li>
</ul>
</li>
</ul>
<h6>Example: A Picture Language</h6>
<h5>Symbolic Data</h5>
<h6>Quotation</h6>
<ul>
<li>
<p><code>&#x27;a</code> returns a symbol: <code>a</code></p>
</li>
<li>
<p><code>&#x27;(a b)</code> evaluates to the list of symbol: <code>(a b)</code></p>
</li>
<li>
<p>Extra: <code>`( )</code> quotes a list where only specific members are evaluated (&quot;quasiquote&quot;). <code>,</code> specifies the evaluated number in such a list.</p>
<ul>
<li>Example: <code>(let ((a 1)) `(a ,a))</code> evals to <code>(a 1)</code>.</li>
</ul>
</li>
<li>
<p><code>(eq? a b)</code> returns whether symbol a and b are the same.</p>
</li>
</ul>
<h6>Example: Symbolic Differentiation</h6>
<h6>Example: Representing Sets</h6>
<ul>
<li>
<p><strong>Sets</strong> are defined by operations on them, i.e. the interface of Set class.</p>
<ul>
<li><code>(adjoin-set elem set)</code></li>
<li><code>(element-of-set? elem set)</code></li>
<li><code>(intersection-set set1 set2)</code></li>
<li><code>(union-set set1 set2)</code></li>
</ul>
</li>
<li>
<p>Underlying implementation can vary:</p>
<ul>
<li>unordered lists</li>
<li>ordered lists</li>
<li>binary trees</li>
</ul>
</li>
</ul>
<h6>Example: Huffman Encoding Trees</h6>
<ul>
<li>prefix code: no complete code (a sequence of bits) is an prefix of another code<!-- -->
<ul>
<li>code automatically get segmented: we can immediately obtain a code when its last bit is received</li>
<li>no need to look forward, because it is the only legal way to decode the symbols</li>
</ul>
</li>
</ul>
<pre><code class="language-scheme">(define sorted-codes
  (fastsort
    (huffman-encode
                &#x27;((a 8) (b 3) (c 4)
                  (d 1) (e 1) (f 1)
                  (g 1) (h 1) (i 9)
                  ))
    (sort-by (lambda (x) (- (caddr x))))))
(map display-code sorted-codes)
; symbol = i      count = 9       code = (0 0)
; symbol = a      count = 8       code = (0 1)
; symbol = c      count = 4       code = (0 1 0)
; symbol = b      count = 3       code = (0 1 1)
; symbol = d      count = 1       code = (1 1 1 1)
; symbol = e      count = 1       code = (1 1 1 0)
; symbol = h      count = 1       code = (0 1 1 1)
; symbol = f      count = 1       code = (0 1 1 0 1)
; symbol = g      count = 1       code = (0 1 1 0 0)
</code></pre></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/series/sicp/2014-05-19-sicp-chapter-2.markdown","slug":["2014-05-19","sicp-chapter-2"],"frontMatter":{"title":"Note for SICP Chapter 2","publishAt":"2014-05-19"}},"mdContent":"\n* toc\n{:toc}\n\n#### Building Abstractions with Data\n\n##### Introduction to Data Abstraction\n\n###### Example: Arithmetic Operations for Rational Numbers\n\n- `cons` forges a pair. `car`, `cdr` takes value out of a pair.\n    - example: `(car (cons a b)) ; =\u003ea`, `(cdr (cons a b)) ; =\u003eb`.\n\n- list is but a special form of pair\n    - `'()` or `nil` is a list\n        - `nil` is not available in MIT-scheme.\n    - The return value of `(cons something \u003ca-list\u003e)` is also a list\n    - `(list a1 a2 ... an)` is short for `(cons a1 (cons a2 ... (cons an nil) ... ))`\n    - In the other direction, a pair is an improper list\n\n###### Abstraction Barriers\n\n###### What Is Meant by Data?\n\n- \"the ability to manipulate procedures as objects automatically provides the ability to represent compound data.\"\n\n###### Extended Exercise: Interval Arithmetic\n\n##### Hierarchical Data and the Closure Property\n\n###### Representing Sequences\n\n- `(cons something a-list)` yields another list.\n\n- `(append list1 list2)` returns concatenation of list1 and list2.\n\n- dotted-tail notation: `(define (foo arg1 arg2 . rest ) \u003cbody\u003e)`\n    - arg1, arg2 capture the first 2 arguments, rest captures the rest.\n\n###### Hierarchical Structures\n\n- `(cons (list 1 2) (list 3 4))` denotes a tree.\n\n- Exercise 2.27: a deep-reverse procedure\n\n      (define (deep-reverse arg)\n        (if (list? arg)\n          (reverse (map deep-reverse a-list))\n          arg))\n      (deep-reverse '(1 (2 3) (4 (5 6)))) ; =\u003e\n\n- Exercise 2.28: flattening a tree (nested list) in left-right order\n\n      (define (fringe arg)\n        (if (list? arg)\n          (apply append (map fringe arg))\n          (list arg)))\n      (display (fringe (list 1 (list 2) (list 3 4 (list 5)) 6)))\n      ; =\u003e (1 2 3 4 5 6)\n\n- Exercise 2.31: a tree-map procedure\n\n      (define (map-tree proc arg)\n        (if (list? arg)\n          (map (lambda (x) (map-tree proc x)) arg)\n          (proc arg)))\n      (define (square x) (* x x))\n      (display\n        (map-tree\n          square\n          '(1 2 (3 4 (5)))) )\n      ; =\u003e (1 4 (9 16 (25)))\n\n###### Sequences as Conventional Interfaces\n\n- \"basic\" operations on a bunch of things:\n    - enumerate: transform something into a list\n\n    - filter: select from a list\n\n          (filter precidate a-list) ; =\u003elist\n\n    - map: transform the list via a proc\n\n          (map proc a-list) ; =\u003elist\n\n    - accumulate: fold a list of things, a.k.a \"fold-right\"\n\n          (define (accumulate op init a-list)\n            (if (null? a-list)\n              init\n              (op (car a-list)\n                  (accumulate op init (cdr a-list)))))\n          ;\n          ;       op\n          ;      /  \\\n          ;    car   op\n          ;         /  \\\n          ;       cadr ...\n          ;               \\\n          ;                op\n          ;               /  \\\n          ;            last  init  ; init is to the \"RIGHT\" of l\n\n    - Use of the preceding \"basic\" operations encourage modular design\n        - Because one have to fit to the known-to-be-common-enough interfaces\n\n    - filter and map can be implemented using accumulate\n\n    - Exercise 2.33: implement `map`, `append`, `my-length` with accumulate\n\n          (define (my-map proc sequence)\n            (accumulate\n              (lambda (head acc) (cons (proc head) acc))\n              '()\n              sequence))\n          (define (my-append seq1 seq2)\n            (accumulate\n              (lambda (head acc) (cons head acc))\n              seq2\n              seq1))\n          (define (my-length sequence)\n            (accumulate\n              (lambda (head acc) (+ 1 acc))\n              0\n              sequence))\n\n    - Exercise 2.36: implement `accumulate-n` with `accumulate`\n\n          (define (accumulate-n op init seqs)\n            (if (null? (car seqs))\n                  '()\n                  (cons (accumulate op init (map car seqs))\n                        (accumulate-n op init (map cdr seqs)))))\n          (accumulate-n\n            +\n            0\n            '((1  2  3)\n              (4  5  6)\n              (7  8  9)\n              (10 11 12))) ; =\u003e '(22 26 30)\n\n    - Exercise 2.38: fold-left\n\n          (define (my-fold-left op init sequence)\n            (if (null? sequence)\n              init\n              (my-fold-left\n                op\n                (op init (car sequence))\n                (cdr sequence))))\n          ;                        op\n          ;                       /  \\\n          ;                    ...   last\n          ;                    /\n          ;                  op\n          ;                 /  \\\n          ;               op   cadr\n          ;              /  \\\n          ; \"LEFT\": initial  car\n\n        - a sufficient condition: when binary operator `op` satisfies `op(a,b) 三 op(b,a)`\n\n    - Exercise 2.40: unique-pairs\n\n    - Exercise 2.41: eight-queens puzzle\n\n###### Example: A Picture Language\n\n##### Symbolic Data\n\n###### Quotation\n\n- `'a` returns a symbol: `a`\n\n- `'(a b)` evaluates to the list of symbol: `(a b)`\n\n- Extra: `` `( ) `` quotes a list where only specific members are evaluated (\"quasiquote\"). `,` specifies the evaluated number in such a list.\n    - Example: ``(let ((a 1)) `(a ,a))`` evals to `(a 1)`.\n\n- `(eq? a b)` returns whether symbol a and b are the same.\n\n###### Example: Symbolic Differentiation\n\n###### Example: Representing Sets\n\n- **Sets** are defined by operations on them, i.e. the interface of Set class.\n    - `(adjoin-set elem set)`\n    - `(element-of-set? elem set)`\n    - `(intersection-set set1 set2)`\n    - `(union-set set1 set2)`\n\n- Underlying implementation can vary:\n    - unordered lists\n    - ordered lists\n    - binary trees\n\n###### Example: Huffman Encoding Trees\n\n- prefix code: no complete code (a sequence of bits) is an prefix of another code\n    - code automatically get segmented: we can immediately obtain a code when its last bit is received\n    - no need to look forward, because it is the only legal way to decode the symbols\n\n~~~ scheme\n(define sorted-codes\n  (fastsort\n    (huffman-encode\n                '((a 8) (b 3) (c 4)\n                  (d 1) (e 1) (f 1)\n                  (g 1) (h 1) (i 9)\n                  ))\n    (sort-by (lambda (x) (- (caddr x))))))\n(map display-code sorted-codes)\n; symbol = i      count = 9       code = (0 0)\n; symbol = a      count = 8       code = (0 1)\n; symbol = c      count = 4       code = (0 1 0)\n; symbol = b      count = 3       code = (0 1 1)\n; symbol = d      count = 1       code = (1 1 1 1)\n; symbol = e      count = 1       code = (1 1 1 0)\n; symbol = h      count = 1       code = (0 1 1 1)\n; symbol = f      count = 1       code = (0 1 1 0 1)\n; symbol = g      count = 1       code = (0 1 1 0 0)\n~~~\n"},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2014-05-19","sicp-chapter-2"]},"buildId":"zVsB8sXV5JsNZvd80Veku","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>