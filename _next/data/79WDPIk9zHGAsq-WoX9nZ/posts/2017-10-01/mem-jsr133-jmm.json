{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2017/2017-10-01-mem-jsr133-jmm.md","slug":["2017-10-01","mem-jsr133-jmm"],"frontMatter":{"title":"TIR: java memory model (JSR133)","publishAt":"2017-10-01"}},"mdContent":"\nJava Language Spec\n\n## Chapter 17: Threads and Locks\n\n### Preface\n\n- memory model defines behaviors that are allowed\n  - JVMs are free to optimize (as long as they only generates allowed behavior)\n\n### 17.1 Synchronization\n\n- 'most basic' synchronization mechism\n- implemented with `monitor`\n- monitor:\n  - exists in each Java object\n  - reentrant\n  - only belongs to 1 thread at any time\n- `synchronized`\n\n  - try to lock on the monitor before run\n  - automatically unlocks when (return OR throw)\n  - no non-blocking try or timeout\n\n- JVM is NOT obliged to detect OR prevent deadlock\n\n### 17.2 Wait Sets and Notification\n\n- Wait Set: a set of threads that are waiting \"on\" the monitor of one object\n- only affacted by `Object.wait()` / `Object#notify` / `Object#notifyAll`\n\n#### 17.2.1 `Object#wait`\n\nif\n\n- caller thread (currentThread) MUST have locked the monitor\n- currentThread MUST NOT be interrupted\n\nthen\n\n- unlock the monitor\n- add currentThread to wait set\n- block currentThread until it gets removed from wait set\n  - removal may happen if:\n    - currentThread gets interrupted\n    - `notify()` called\n    - `notifyAll()` called\n    - timed wait && timeout\n- lock the monitor again\n- (if block ended due to interruption) `wait() throws InterruptedException\n\n#### 17.2.2 `Object#notify()` / `Object#notifyAll()`\n\n- currentThread must have locked the monitor\n- remove 1 or all threads from wait set\n  - in case of notifyAll, _ONLY 1_ thread would be able to lock again\n- NOTE: this DOES NOT unlock the monitor (so NO thread removed from Wait Set can succeed until currentThread unlocks)\n\n#### 17.2.3 Interruptions\n\n#### 17.2.4 Interactions of waits / notifation / interruption\n\n### 17.3 Sleep and Yield\n\n`Thread.sleep()` / `Thread.yield()`\n\n- sleep DOES NOT lose ownership of monitors\n- NEITHER Thread.sleep NOR have synchronization semantics\n\n### 17.4 Memory Model\n\n\"possible behaviors of a program\"\n\n- whether an execution trace (instructions?) is a legal execution of the program (code?)\n- \"legal\" := each _read_ MUST observe some _write_ that is valid according to certain rules\n\n- intra-thread semantics\n  - semantics for single-threaded programs\n\n#### 17.4.1 Shared Variables\n\n- \"shared variable\": instance fields / static fields / array elements\n  - in contrast to single-threaded : local variables / method params / execution handler params\n- \"conflicting\": two accesses to the same variable if at least 1 of them is write\n\n#### 17.4.2 Actions\n\n**inter-thread action** or simply \"action\": an action that can be detected or directly-influenced by another thread\n\nintra-thread actions do not concern us: all threads need to obey intra-thread semantics\n\npossible (inter-thread) actions:\n\n- non-volatile read\n- non-volatile write\n- **synchronized actions**\n  - volatile read\n  - volatile write\n  - lock of monitor\n  - unlock of monitor\n  - first and last action of a thread\n  - actions that start a thread, or detect termination of a thread\n- \"external\" action\n  - an action that may be observable outside of an execution (`side effect` ?), and have a result based on an environment external to the execution (`RealWorld` ?)\n- thread divergence action, or \"dead loop\"\n\n#### 17.4.3 Programs and Program Order\n\n(_program order_ of thread _t_): a total order that obeys intra-thread semantics of _t_\n\na set of actions is _sequentially consistent_ if\n\n- the actions occur in a total order _\"execution order_ that is consistent with program order\n- AND each read r of variable v sees (last write to v in execution order)\n\n\"sequential consistency\" as a language model prohibits many compiler optimizations\n\n#### 17.4.4 Synchronization order\n\na synchronization order is a total order over all the _synchronization actions_ of an execution.\n\nFor each thread t, the **synchronization order** of synchronization actions in t is consistent with the **program order** of t.\n\nSynchronization actions induce **synchronized-with** relation relation of actions:\n\n- unlock _synchronized-with_ all subsequent lock\n- a volatile write _synchronized-with_ all subsequent volatile read\n- starting a thread _synchronized-with_ first action in that thread\n- final action of a thread T _synchronized-with_ actions of thread T2, if T2 dectes T has terminatedd\n- interruption of thread blah blah\n- write of default value _synchronized-with_ first action in every thread\n  - \"conceptually every object is created at start of program\"\n\n#### 17.4.5 Happens-before order\n\n2 actions can be ordered by a **happens-before** relationship\n\nIf x happens before y, then: x is visible to y AND is ordered before y\n\nx happens before y if:\n\n- x and y are actions of the same thread, and x comes before y in program order\n- OR: x is (end of constructor) and y is (start of finalizer)\n- OR: x synchronized-with y\n- OR: x happens-before some z, and z happens-before y (i.e. happens-before is a transitive relation)\n\nNOTE: happens-before does not require certain order in execution (implementation may reorder as long as all observations obeys _happens-before_)\n\nhappens-before relation defines **data races**: if 2 **conflicting accesses** are not ordered by a **happens-before** relationship, the program is said to contain a **data race**.\n\na program is **correctly synchronized** IFF all sequentially consistent executions are free of data races.\n\nif a program is **correctly synchronized**, then **all** executions of the program will appear to be sequentially consistent\n\nread r of varable v is allowed to observe a write w if\n\n**happens-before consistency**:\n"},"__N_SSG":true}