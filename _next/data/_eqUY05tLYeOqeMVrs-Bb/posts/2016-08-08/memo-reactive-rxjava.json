{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2016/2016-08-08-memo-reactive-rxjava.md","slug":["2016-08-08","memo-reactive-rxjava"],"frontMatter":{"title":"Memo: Reactive (RxJava)","publishAt":"2016-08-08"}},"mdContent":"\n* toc\n{:toc}\n\n## Observable and peers\n\n`A immutable asynchronous stream`\n\n### Subscribe-able\n\nTypes that can be subscribed to:\n\n```text\nBase:\n    Emitter<T>\n\nObservable<T>: T* (Completion|Error)\n    - Base reactive class\n\nSingle<T>: T (Completion | Exception)\n\nCompletable: Completion | Exception\n    - effectively Single<Unit>\n\nMaybe<T>: T? (Completion | Exception)\n    - effectively Single<Unit?>\n\nFlowable:\n    - a backpressure-enabled base reactive class, new in RxJava 2.0\n```\n\n`subscribe` to one of them causes event to flow through observer.\n\n### \"Hot\" and \"Cold\"\n\n\n## Transformation and Operators\n\n\"transforms\" a observable\n\n```hs\n-- map as in Array#map\nmap     :: Observable T1 -> (T1 -> T2) -> Observable T2\n\n-- flatMap or (map and then flatten)\nflatMap :: Observable T1 -> (T1 -> Observable T2) -> Observable T2\n\n-- filter as in Array#filter\nfilter  :: Observable T1 -> (T1 -> bool) -> Observable T1\n\n-- doOnNext: like Array#tap in ruby\ndoOnNext :: Observable T1 -> (T1 -> void) -> Observable T1\n```\n\n### Back pressure\n\n- when consumer is not able to handle all events from upstream\n- Makes difference on hot observables than cold ones\n\n### Creating\n\n1. `Observable<T> Observable.create(Observable.OnSubscript<T> onsubscribe)`\n2. `Observable<T> Observable.just(T value)`\n\n## Subscribe\n\n1. A complete `Subscriber<T>` with `onNext` / `onCompleted` / `onError`\n2. `Action1<T>` that only responds to `onNext`\n    - Q: what if it completed / errored?\n\n## Subscriber\n\n- Observer\n\n\n\n### Creation\n\n- From existing collection: `Observable::create`\n- From existing value: `Observable::Just`\n\n## Threading\n\n\n## Observe\n\n`<Observable>#subscribe(<Observer>)`\n\n## Generalization\n\nI am still in a process to generalize different \"value containers\".\n\nFor a value type `T`, we have:\n- `T` itself\n    - exactly 1 value, already available for computation.\n- Array: `T[]` or `Array<T>`\n    - 0 or many values, already available for computation.\n- Promise: `Promise<T>`\n    - exactly 1 value, or exactly 1 error (or stay unresolved)\n    - \"timeless\": then/catch handlers bound to a Promise gets executed after resolve\n        - so is `subsequent` promises retured by then/catch\n- `Observable<T>`:\n    - 0 or many values, followed by a complete or a error (or never finishes)\n    - handlers (subscribers)\n    - `Flowable<T>` have same form but different behavior\n- `Single<T>`\n    - `Completable` is effectively `Single<Void>`\n\n## Ref\n\n- https://github.com/reactive-streams/reactive-streams-jvm/\n"},"__N_SSG":true}