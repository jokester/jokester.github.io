{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/series/sicp/2014-05-16-sicp-chapter-1.markdown","slug":["2014-05-16","sicp-chapter-1"],"frontMatter":{"title":"Note for SICP Chapter 1","publishAt":"2014-05-16"}},"mdContent":"\n* toc\n{:toc}\n\n#### Building Abstractions with Procedures\n\n##### The Elements of Programming\n\n###### Expressions\n\n- primitive expression\n    - number: `486`\n    - primitive operators (are also procedures): `< = > and or not`\n\n- compound expression\n    - application of some **procedure** to some **arguments**: `(+ 1 2)`\n\n###### Naming and the Environment\n\n- naming: assign name to something (\"object\")\n    - value: `(define foo 1)`\n    - procedure: `(define (bar arg1) (+ 1 2))`\n\n- environment: memory of name-object pairs\n    - a computation may involve multiple environments\n\n###### Evaluating Combinations\n\n- steps of \"applicative order\"\n\n    - evaluate every subexpressions\n    - apply the leftmost subexpression (\"operator\") to the values of the other subexpressions (\"operands\")\n\n###### Compound Procedures\n\n- general form of procedure definition:\n\n```\n      (define (<name> <formal parameters>)\n          <body>)\n```\n\n    The `<body>' part may contain multiple expressions. The value of the final expression becomes the value of the procedure application.\n\n###### The Substitution Model for Procedure Application\n\n- evaluate the body of procedure with the formal parameters replaced by the corresponding arguments\n\n- is presented to help think about the process of application, and **is not** how interpreter works\n\n- order of execution\n    - normal order: \"fully expand and then reduce\"\n    - applicative order: \"evaluate the arguments and then apply\"\n    - lisp uses applicative order evaluation.\n\n###### Conditional Expressions and Predicates\n- if\n\n    `if` is a special form and not a procedure.\n    It only evalutes the predicate and **one of** the consequent / alternative expression.\n\n      (if (> 1 0) #t #f)\n\n- cond\n\n    `cond` is a special form and not a procedure.\n    It only evalutes the predicates till the correct branch, and that corresponding branch.\n\n      (cond\n          ((= a 1) 1)\n          ((= a 2) 3))\n\n###### Example: Square Roots by Newton’s Method\n\n- code\n\n      (define (newton-sqrt aim)\n        (define (guess-till-good-enough current next-guess good-enough?)\n          (if (good-enough? current)\n            current\n            (guess-till-good-enough (next-guess current) next-guess good-enough?)))\n        (define (small-enough? delta) (< delta 1e-5))\n        (define (close-enough? current) (small-enough? (abs (- (* current current) aim))))\n        (define (better-approximation-of-sqrt current) (/ (+ current (/ aim current)) 2)) ;; << the ``Newton'' part\n        (define initial-guess 1.1)\n        (guess-till-good-enough initial-guess better-approximation-of-sqrt close-enough?))\n\n      (display (newton-sqrt 2.0))\n      ; => 1.4142\n\n###### Procedures as Black-Box Abstractions\n\n- The definition suppresses the details.\n\n- The user of a procedure does not need to know the internal.\n\n- Local names\n    - The formal parameters are **local** to the body. AKA \"bound variable\" or \"captured variable\"\n    - e.g. `(define (square x) (* x x))` contains a bound variable `x` and a free variable `*`.\n    - The name of formal parameters can be arbitrary.\n\n- Internal definitions (refer to previous `newton-sqrt` procedure)\n    - One can localize subprocedures with nested `define`.\n    - The free variable in inner procedure get its value from the bound variable of outer procedure, AKA **lexical scoping**.\n    - Example of lexical scoping: `aim` in `(define (close-enough? current <body>)`.\n\n##### Procedures and the Processes They Generate\n\n###### Linear Recursion and Iteration\n\n- Recursive computation of factorial\n\n      (define (factorial n)\n        (if (= n 0)\n          1\n          (* n (factorial (- n 1)))))\n\n- Iterative computation of factorial\n\n      (define (factorial n)\n        (define (factorial-iter cumulative-product current max)\n          (if (> max current)\n            cumulative-product\n            (factorial-iter (* cumulative-product current) (+ current 1) max)))\n        (factorial-iter 1 1 n))\n\n- The preceding 2 procedures produce different **shape of computation**.\n\n###### Tree Recursion\n\n- Example: recursive definition of `(fib n)`\n\n- Example: counting change\n\n      (define (change coins rest)\n        (cond\n          ((< rest 0) 0)\n          ((= rest 0) 1)\n          ((= (length coins) 0) 0)\n          (else (+\n            (change coins (- rest (car coins)))\n            (change (cdr coins) rest)))))\n      (display (change (list 50 25 10 5 1) 100))\n      ; => 292\n\n###### Order of Growth\n\n- refer to **shape of computation**\n\n###### Exponentiation\n\n- implement `(power base exp)` with linear recursion\n\n- implement `(power base exp)` with log recursion\n- exercise 1.19: implement `(fib n)` with log recursion\n        (let ((a 1)) (+ a 2))\n\n###### Greatest Common Divisors\n\n- Euclid’s Algorithm\n\n###### Example: Testing for Primality\n\n- code\n\n      (define (prime? n)\n        (define (find-first-divisor current)\n          (cond\n            ((= (remainder n current) 0) current)\n            ((> (* current current) n)   #f)\n            (else (find-first-divisor (+ 1 current)))))\n        (define first-divisor (find-first-divisor 2))\n        (if (and first-divisor (not (= n first-divisor)))\n          #f\n          #t))\n\n##### Formulating Abstractions with Higher-Order Procedures\n\n###### Procedures as Arguments\n\n- `map`\n- `sum`, `integral`\n\n###### Constructing Procedures Using Lambda\n\n- One can create (anonymous) procedures with the special form `lambda`\n\n    - usage\n\n          (lambda (formal-parameters) <body>)\n\n    - example\n\n          (map (lambda (x) (* x x)) '(1 2 3))\n\n- One can use `lambda` to bind local variables, but the special form `let` makes it more convenient.\n\n    - usage\n\n          (let ((<name> <expression>)+) <body>)\n\n    - \"is but syntactic sugar of underlying lambda expression\"\n\n    - The name-expression pairs in `let` are parallel. One expression cannot refer to another name.\n\n###### Procedures as General Methods\n\n- Example: finding zero-point with the half-interval method\n\n- Example: finding fixed-point\n\n###### Procedures as Returned Values\n\n- rights of **first-class** elements\n    - can be assigned a name\n    - can be passed as argument\n    - can be returned by procedure\n    - can be included in data structures\n"},"__N_SSG":true}