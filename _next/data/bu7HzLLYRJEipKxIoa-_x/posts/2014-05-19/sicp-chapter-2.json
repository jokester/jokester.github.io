{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/series/sicp/2014-05-19-sicp-chapter-2.markdown","slug":["2014-05-19","sicp-chapter-2"],"frontMatter":{"title":"Note for SICP Chapter 2","publishAt":"2014-05-19"}},"mdContent":"\n* toc\n{:toc}\n\n#### Building Abstractions with Data\n\n##### Introduction to Data Abstraction\n\n###### Example: Arithmetic Operations for Rational Numbers\n\n- `cons` forges a pair. `car`, `cdr` takes value out of a pair.\n    - example: `(car (cons a b)) ; =>a`, `(cdr (cons a b)) ; =>b`.\n\n- list is but a special form of pair\n    - `'()` or `nil` is a list\n        - `nil` is not available in MIT-scheme.\n    - The return value of `(cons something <a-list>)` is also a list\n    - `(list a1 a2 ... an)` is short for `(cons a1 (cons a2 ... (cons an nil) ... ))`\n    - In the other direction, a pair is an improper list\n\n###### Abstraction Barriers\n\n###### What Is Meant by Data?\n\n- \"the ability to manipulate procedures as objects automatically provides the ability to represent compound data.\"\n\n###### Extended Exercise: Interval Arithmetic\n\n##### Hierarchical Data and the Closure Property\n\n###### Representing Sequences\n\n- `(cons something a-list)` yields another list.\n\n- `(append list1 list2)` returns concatenation of list1 and list2.\n\n- dotted-tail notation: `(define (foo arg1 arg2 . rest ) <body>)`\n    - arg1, arg2 capture the first 2 arguments, rest captures the rest.\n\n###### Hierarchical Structures\n\n- `(cons (list 1 2) (list 3 4))` denotes a tree.\n\n- Exercise 2.27: a deep-reverse procedure\n\n      (define (deep-reverse arg)\n        (if (list? arg)\n          (reverse (map deep-reverse a-list))\n          arg))\n      (deep-reverse '(1 (2 3) (4 (5 6)))) ; =>\n\n- Exercise 2.28: flattening a tree (nested list) in left-right order\n\n      (define (fringe arg)\n        (if (list? arg)\n          (apply append (map fringe arg))\n          (list arg)))\n      (display (fringe (list 1 (list 2) (list 3 4 (list 5)) 6)))\n      ; => (1 2 3 4 5 6)\n\n- Exercise 2.31: a tree-map procedure\n\n      (define (map-tree proc arg)\n        (if (list? arg)\n          (map (lambda (x) (map-tree proc x)) arg)\n          (proc arg)))\n      (define (square x) (* x x))\n      (display\n        (map-tree\n          square\n          '(1 2 (3 4 (5)))) )\n      ; => (1 4 (9 16 (25)))\n\n###### Sequences as Conventional Interfaces\n\n- \"basic\" operations on a bunch of things:\n    - enumerate: transform something into a list\n\n    - filter: select from a list\n\n          (filter precidate a-list) ; =>list\n\n    - map: transform the list via a proc\n\n          (map proc a-list) ; =>list\n\n    - accumulate: fold a list of things, a.k.a \"fold-right\"\n\n          (define (accumulate op init a-list)\n            (if (null? a-list)\n              init\n              (op (car a-list)\n                  (accumulate op init (cdr a-list)))))\n          ;\n          ;       op\n          ;      /  \\\n          ;    car   op\n          ;         /  \\\n          ;       cadr ...\n          ;               \\\n          ;                op\n          ;               /  \\\n          ;            last  init  ; init is to the \"RIGHT\" of l\n\n    - Use of the preceding \"basic\" operations encourage modular design\n        - Because one have to fit to the known-to-be-common-enough interfaces\n\n    - filter and map can be implemented using accumulate\n\n    - Exercise 2.33: implement `map`, `append`, `my-length` with accumulate\n\n          (define (my-map proc sequence)\n            (accumulate\n              (lambda (head acc) (cons (proc head) acc))\n              '()\n              sequence))\n          (define (my-append seq1 seq2)\n            (accumulate\n              (lambda (head acc) (cons head acc))\n              seq2\n              seq1))\n          (define (my-length sequence)\n            (accumulate\n              (lambda (head acc) (+ 1 acc))\n              0\n              sequence))\n\n    - Exercise 2.36: implement `accumulate-n` with `accumulate`\n\n          (define (accumulate-n op init seqs)\n            (if (null? (car seqs))\n                  '()\n                  (cons (accumulate op init (map car seqs))\n                        (accumulate-n op init (map cdr seqs)))))\n          (accumulate-n\n            +\n            0\n            '((1  2  3)\n              (4  5  6)\n              (7  8  9)\n              (10 11 12))) ; => '(22 26 30)\n\n    - Exercise 2.38: fold-left\n\n          (define (my-fold-left op init sequence)\n            (if (null? sequence)\n              init\n              (my-fold-left\n                op\n                (op init (car sequence))\n                (cdr sequence))))\n          ;                        op\n          ;                       /  \\\n          ;                    ...   last\n          ;                    /\n          ;                  op\n          ;                 /  \\\n          ;               op   cadr\n          ;              /  \\\n          ; \"LEFT\": initial  car\n\n        - a sufficient condition: when binary operator `op` satisfies `op(a,b) ä¸‰ op(b,a)`\n\n    - Exercise 2.40: unique-pairs\n\n    - Exercise 2.41: eight-queens puzzle\n\n###### Example: A Picture Language\n\n##### Symbolic Data\n\n###### Quotation\n\n- `'a` returns a symbol: `a`\n\n- `'(a b)` evaluates to the list of symbol: `(a b)`\n\n- Extra: `` `( ) `` quotes a list where only specific members are evaluated (\"quasiquote\"). `,` specifies the evaluated number in such a list.\n    - Example: ``(let ((a 1)) `(a ,a))`` evals to `(a 1)`.\n\n- `(eq? a b)` returns whether symbol a and b are the same.\n\n###### Example: Symbolic Differentiation\n\n###### Example: Representing Sets\n\n- **Sets** are defined by operations on them, i.e. the interface of Set class.\n    - `(adjoin-set elem set)`\n    - `(element-of-set? elem set)`\n    - `(intersection-set set1 set2)`\n    - `(union-set set1 set2)`\n\n- Underlying implementation can vary:\n    - unordered lists\n    - ordered lists\n    - binary trees\n\n###### Example: Huffman Encoding Trees\n\n- prefix code: no complete code (a sequence of bits) is an prefix of another code\n    - code automatically get segmented: we can immediately obtain a code when its last bit is received\n    - no need to look forward, because it is the only legal way to decode the symbols\n\n~~~ scheme\n(define sorted-codes\n  (fastsort\n    (huffman-encode\n                '((a 8) (b 3) (c 4)\n                  (d 1) (e 1) (f 1)\n                  (g 1) (h 1) (i 9)\n                  ))\n    (sort-by (lambda (x) (- (caddr x))))))\n(map display-code sorted-codes)\n; symbol = i      count = 9       code = (0 0)\n; symbol = a      count = 8       code = (0 1)\n; symbol = c      count = 4       code = (0 1 0)\n; symbol = b      count = 3       code = (0 1 1)\n; symbol = d      count = 1       code = (1 1 1 1)\n; symbol = e      count = 1       code = (1 1 1 0)\n; symbol = h      count = 1       code = (0 1 1 1)\n; symbol = f      count = 1       code = (0 1 1 0 1)\n; symbol = g      count = 1       code = (0 1 1 0 0)\n~~~\n"},"__N_SSG":true}