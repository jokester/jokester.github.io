{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2016/2016-12-12-memo-category-theory-for-programmers.md","slug":["2016-12-12","memo-category-theory-for-programmers"],"frontMatter":{"title":"Memo: Category Theory for Programmers","publishAt":"2016-12-12"}},"mdContent":"\nThis post serves as a memo of [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) series for myself.\n\nAs a programmer without much math / algebra background, I cannot overstate my gratitude to the author of this series: Bartosz Milewski.\n\n## Part 1\n\n### 1. Category: The Essence of Composition\n\nDefinition of category: \"objects\" and \"arrows aka _morphisms_\".\n\nThe morphisms must have 2 characticics in order to form a category:\n\n- transitive: if `A -> B` and `B -> C` exists, `A -> C` must exist.\n- reflexive: for any object x, `X -> X`, or _identity morphism_ must exist.\n\n`0` in addition --- `id` in morphism.\n\nComposition is ubiqutious in programming. It helps by limiting the concept we have to deal simultaneously.\n\n### 2. Types and Functions\n\nTypes helps us to find incorrect code at early stage (_fail fast_).\n\n> Testing is almost always a probabilistic rather than a deterministic process.\n> Testing is a poor substitute for proof.\n\nTypes can be considered _sets of values_, while morphisms / arrows being functions.\n\n`Hask`: the category of Haskell types and functions, that is like `Set: category of sets` but contains `_|_` (bottom, or `undefined :: a`) for computation that never ends.\n\nSpecial types:\n\n- `Void` the type that have no values\n- `()` the type that have 1 value, `()`\n\nChallange 6.\n\n```text\n() -> () : 1ã€€arrows\n    _ -> ()\n\nBool -> Bool: 4 arrows\n    _ -> True\n    _ -> False\n    _ -> _\n    _ -> !_\n\nVoid -> Void: 1 arrows (I'm not pretty confident, but it cannot be more than 1 so)\n```\n\n### 3. Categories Great and Small\n"},"__N_SSG":true}