{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2017/2017-03-30-monoid-fast-exp.md","slug":["2017-03-30","monoid-fast-exp"],"frontMatter":{"title":"Fast exp() operator for Monoids","publishAt":"2017-03-30"}},"mdContent":"\nToday I learned that the fast-exponentiation in [SICP 1.2.4](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.4) can be applied to all monoids as well.\n\n## Monoid\n\nDefinition: set `S` and operation `⊕ : S -> S -> S` forms a **Monoid** if they satisfy:\n\n- **Associativity**: `(x ⊕ y) ⊕ z === x ⊕ (y ⊕ z)` for `x, y, z` in `S` .\n- **Identity element**, or **Unit**: `I` such that `x ⊕ I === x === I ⊕ x` exists.\n\n### Example of Monoid: Plus\n\nWe can see that the set of all real numbers, `R`, and `a ⊕ b := a + b` forms a Monoid, where `I = 0`.\n\n### More examples of Monoid\n\n- `R`, and `a ⊕ b := a * b` forms a Monoid, where `I = 1`.\n- When N is an integer, Set of all integers `Z`, and `a ⊕ b := (a + b) mod N` forms a Monoid, where `I = 0`.\n\n## \"Multiplication\" of Monoid\n\nIf we consider `⊕` to be a general form of `plus`, we can define a general form of `multiply`, denoted by operator `⊗`:\n\n- Let k be `k` a non-negative integer\n- `a ⊗ 0 := I` when `k == 0`\n- `a ⊗ k := a ⊕ (a ⊗ (k-1))` when `k > 0`\n\nThis makes `a ⊗ k := a ⊕ a ⊕ a ⊕ a ⊕ a ⊕ a ⊕ a ⊕ a ⊕ a ...` where the right hand side is `k` `a`s concatencated by `⊕`.\n\n- When `a ⊕ b` is `a + b`, `⊗` becomes `*`.\n- When `a ⊕ b` is `a * b`, `⊗` becomes `**`.\n- When `a ⊕ b` is `(a + b) % N`, `a ⊗ b` becomes `(a * b) % N`.\n\n## `a ⊗ k` can be computed in `O(ln2 k)`\n\nLet binary representation of `k` be `B(m) B(m-1) ... B(0)` where B0 is the LSB. We can rewrite `a ⊗ k` to be:\n\n`a ⊗ k := (a ⊗ (2**B(m))) ⊕ (a ⊗ (2**B(m-1))) ⊕ ... ⊕ (a ⊗ (2**B(0)))`\n\nIf `⊕` has `O(1)`, `a ⊗ k` can be computing in `O(ln2 k)`. The key idea is to reuse `a ⊗ (2**B(m-1))` when computing `a ⊗ (2**B(m))`, with dynamic-programming.\n\nComputing `*` in this way is not quite fruitful: we know that processor can compute `a * b` in `O(1)`.\n\nHowever things are different in the case of `a * b` and `(a + b) % N`. Applying our fast-`⊗` method to them can save both time and space.\n\n## Code\n\n```ts\nfunction fastMul<T>(id: T, mplus: (op1: T, op2: T) => T, a: T, k: number): T {\n  if (~~k !== k || k < 0) throw new Error('exp must be positive integer');\n\n  let ans = id;\n\n  while (k > 0) {\n    if (k % 2 == 1) {\n      ans = mplus(ans, a);\n      k--;\n    } else {\n      a = mplus(a, a);\n      k /= 2;\n    }\n  }\n\n  return ans;\n}\n\n// 2**5\nconsole.log(fastMul(1, (a, b) => a * b, 2, 5));\n\n// (887 * 885) % 12\nconsole.log(fastMul(0, (a, b) => ((a % 12) + (b % 12)) % 12, 887, 885));\n```\n"},"__N_SSG":true}