{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2017/2017-11-01-memo-redis.md","slug":["2017-11-01","memo-redis"],"frontMatter":{"title":"Memo: Redis","publishAt":"2017-11-01"}},"mdContent":"\n# Redis\n\n- in-memory K-V data structure store\n- can be used for database / cache / message broker\n\n## Data types\n\n### Type of Value\n\nString-centred:\n\n- string\n- list (of strings)\n  - internally linked list\n- set (of strings)\n- sorted sets (of strings)\n  - where every string is attached a floating number value (weight?)\n  - internally, maybe sth like heap?\n- hash of `<string, string>`\n\nOthers (todo: read):\n\n- bitmap (aka bit array)\n- HyperLogLogs\n\n### Type of Key\n\nstring\n\n- try use a schema: `user:1000:followers`\n- a too-long string as key may harm performance (uuid / sha as string should be fine)\n\nredis keys are \"binary safe\" strings. i.e. they can be any byte sequence, and not necessarily char sequence.\n\n## Concept\n\n### Value\n\n### Atomcity\n\nall commands are atomic, including commands about multi values (`MGET / MSET`) too.\n\n### Expire\n\n## Commands\n\n### Key\n\n- EXISTS key\n  - see if key exists\n- DEL key\n  - del the key\n- TYPE key\n  - return `none | list`\n\n### Expire\n\n- EXPIRE / PEXPIRE\n  - set expire with relative time\n- EXPIREAT / PEXPIREAT\n  - set expire with current time\n- `TTL` / `PTTL`\n  - query\n- `PERSIST key`\n  - removes the expiration\n\n### `string`\n\n- `SET key value [EX expire_in_sec][px expire_in_msec] [NX|XX]\n  - EX/PX flag: set expire (relative time)\n  - NX flag: only set if not exist\n  - XX flag: only set if exist\n  - can be used to implement a (not fool-proof) mutex lock: see [SET / patterns](https://redis.io/commands/set)\n- GET\n- INCR / DECR / INCRBY / DECRBY\n  - `++x` or `x+= delta`\n  - the string and the delta must represent decimal integer\n  - returns new value\n  - delta must be integer\n- GETSET key new-value\n  - return old value (may be nil)\n\n### `list`\n\n- LPUSH / RPUSH\n  - runs in `O(1)` time\n  - add string values to (left | right) of list\n  - `lpush key a b c` results in a list of `c b a ...`\n  - returns number of values pushed\n  - creates list if not exist\n  - fails if the key exists but value is not list\n- LPOP / RPOP / BLPOP / BRPOP\n  - pop 1 element from left / right\n  - return nil on empty list\n  - list gets removed if it had 1 element\n- BRPOP / BLPOP\n  - like LPOP / RPOP\n  - differs in that B-POP would block on empty list, until there is sth to return\n    - won't stop blocking if value is changed to a non-list\n  - FIFO: the first client started waiting, gets served first\n  - timeout: max block time in second (sepcify 0 to block indefinitely)\n- LRANGE\n  - `LRANGE key start end`\n  - get values from list\n  - both start / end are inclusive\n  - -1 means last index, -2 means last but 1\n    - so `LRANGE key 0 -1` gets all\n- LLEN\n  - get length of list\n  - may need `O(n)` time\n- LTRIM\n  - trims a list to a range\n  - \"capped list\" pattern: trim after push, to limit capacity\n- LINSERT\n  - insert new value before/after a pivot\n\ncomplicated:\n\n- RPOPLPUSH src dest\n  - atomic `LPUSH dest $ RPOP src`\n  - returns the element\n  - TODO: read patterns https://redis.io/commands/brpoplpush\n\n### `hash`\n\n- HSET / HGET : 1 field-value pair\n- HMSET / HMGE: multi pairsT\n- HGETALL\n  - returns `[field1, value1, field2, value2, ...]`\n- HLEN: `#fields`\n\nOperation on values:\n\n- HSETNX\n  - sets field only if not exist\n- HINCBY / HINCBYFLOAT\n- HSCAN\n  - iterator\n\n### `set`\n\n- SADD\n- SISMEMBER\n- SINTER\n  - intersection\n- SUNIONSTORE\n  - compute union of 2 stores, and save to another set\n- SPOP\n  - pop a _random_ element\n- SCARD\n  - return cardinal of set\n\n### `sorted set`\n\nSets, where each element is attached a numerical (IEEE754 float64, double-precision) `score`.\n\nElements are in a (strict) `total order`\n\n- ZADD\n- ZINCRBY\n- ZSCORE\n  - get score by element\n- ZCARD\n- ZCOUNT ZLEXCOUNT\n  - count elements in a range (by score / by key)\n- ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZREVRANGE ZREVRANGEBYLEX ZREVRANGEBYSCORE\n  - get elements in a range of rank (ranked by score or lexicographical)\n  - can get scores too (WITHSCORES)\n- ZREM ZREMRANGEBYSCORE ZREMRANGEBYRANK ZREMRANGEBYLEX\n  - del element\n- ZRANK ZREVRANK\n  - get index when sorted by key\n- ZINTERSTORE ZUNIONSTORE\n  - merge 2 or more sorted sets\n  - aggregation function of scores: SUM (default) / MIN / MAX\n- ZSCAN\n  - iterator\n\n## Server\n\n### Persistency\n\n- ahead of toi\n\n## c\n"},"__N_SSG":true}