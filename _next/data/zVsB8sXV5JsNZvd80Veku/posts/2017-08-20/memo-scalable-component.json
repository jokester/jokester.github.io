{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2017/2017-08-20-memo-scalable-component.md","slug":["2017-08-20","memo-scalable-component"],"frontMatter":{"title":"Scalable Component Abstractions","publishAt":"2017-08-20"}},"mdContent":"\n## 2 Scala 的用于组合 class 的机制\n\n### 2.1\n\n#### Abstract Type Numbers\n\n一个抽象类可以以抽象的类型为成员。\n\n```scala\nabstract class AbsCell {\n    type T;\n    val init: T;\n    // 其他成员也可使用T, 比如以T为方法参数或返回值\n}\n```\n\n这样一个抽象类型的成员可以在创建时才具体指定:\n\n```scala\nval cell = AbsCell { type T = int; val init = 1 }\n```\n\n#### Path-dependent types\n\n没有看懂\n\n#### Parameter bounds\n\n没有看懂\n\n### 2.2 Modular Mixin Composition\n\n`trait` 是特殊的抽象类, 要求 constructor 没有 value 参数.\n\n抽象类可以用于 `extend` (继承) 或 `with` (mixin).\n\n#### Class Linearation\n\n一个类型可能 extend 一个, mixin 多个类型, 而且此过程是递归的.\nClass Linearation 定义怎样从一个类型的所有 superclass (graph) 求出一个 _严格全序_ 的 superclass 链 (list).\n这个链用于 override / super 的 resolution\n\n#### Super calls\n\n因为, `A extend B` 不保证在被用于组合后, A 中的 super 仍然指 B.\n\n### 2.3 Selftype Annotations\n\n可以为一个类另外指定这个类中的 this 的类型.\n\n### 2.4 Service-Oriented Component Model\n\n还没看懂\n"},"__N_SSG":true}